# Техническое задание: VPN бот self-service для выдачи конфигов WireGuard

## Что надо сделать

Реализовать в проекте VPN полноценный поток self-service через Telegram-бота, чтобы владелец мог добавлять друзей/коллег, а они сами получали персональные конфиги WireGuard (и при необходимости QR-коды) через команды бота без ручного редактирования `wg0.conf`. На текущем этапе предполагается один активный peer (подключение в WireGuard) на один Telegram-аккаунт.

## Как это должно работать

- **Роли:**
  - Владелец (owner) — Telegram-аккаунт с правами управления (админ бота).
  - Обычный пользователь (user) — друг/коллега, которому владелец даёт доступ.

- **Поток для владельца:**
  - Владелец добавляет пользователя командой `/add_user`:
    - как ответ на сообщение пользователя;
    - или `/add_user <telegram_id>`;
    - или `/add_user @username` (в этом случае пока сохраняется только username, ID привяжется при первом сообщении боту).
  - Владелец может посмотреть список пользователей через `/users` (id, username, роль, статус active/disabled).

- **Поток для друга/коллеги:**
  - Друг переходит в бот и пишет `/start`:
    - если он добавлен и активен, видит приветствие и список команд;
    - если нет — получает внятное сообщение, что нужно попросить владельца добавить его.
  - Друг вызывает `/get_config` (или `/my_config`):
    - Бот проверяет, что пользователь есть в `users.json` и `active=True`.
    - Бот ищет связанный peer в `peers.json` по `telegram_id`.
      - **Если peer уже есть и активен:**
        - бот повторно выдаёт ему его персональный конфиг (`client_<telegram_id>.conf`) и, по запросу, QR-код;
      - **Если peer отсутствует:**
        - бот создаёт новый peer (через интеграцию с WireGuard):
          - генерирует ключи;
          - выбирает свободный IP в VPN-подсети;
          - добавляет `[Peer]` в конфиг сервера;
          - применяет изменения (`wg syncconf` или аналог);
          - формирует текст клиентского `.conf`;
          - сохраняет данные peer в `peers.json`;
        - отправляет пользователю конфиг/QR.
  - Команда `/regen`:
    - помечает старый peer как неактивный, создаёт новый peer с новыми ключами (можно с тем же IP или новым);
    - обновляет серверную конфигурацию WireGuard;
    - выдаёт новый конфиг/QR пользователю.
  - Команда `/status`:
    - показывает, активен ли доступ;
    - с какой нодой он связан (пока одна нода — `main`, Timeweb);
    - базовую информацию (дата создания/обновления, при наличии).

## Какие инструменты нам понадобятся

- Существующий Telegram-бот на `pyTelegramBotAPI` (`telebot`), уже используемый в `VPN/bot/main.py`.
- Локальное хранилище JSON:
  - `users.json` — уже реализовано;
  - новый `peers.json` — реализуем через датакласс `Peer`.
- Интеграция с WireGuard на сервере:
  - вызов CLI-команд `wg`, `wg-quick`, редактирование `/etc/wireguard/wg0.conf`;
  - для первого этапа — через локальные скрипты/подпроцессы из того же окружения, где крутится бот.
- Библиотека для генерации QR-кодов:
  - на сервере уже используется `qrencode` для CLI;
  - опционально — Python-библиотека (`qrcode`) для генерации PNG для отправки в Telegram.

## Какая информация нам потребуется

- [ ] Точное расположение кода VPN-бота на сервере (папка проекта и имя systemd-сервиса).
- [ ] Подтверждение, что бот и WireGuard нода работают на одном и том же сервере (предполагается Да).
- [ ] Фактический диапазон IP-адресов, используемый в `wg0.conf` (например, `10.0.0.0/24`).
- [ ] Текущая запись peer для владельца (client1), чтобы решить, импортируем ли мы её в `peers.json` или создаём новую.

## Как должен выглядеть результат

- [ ] Владелец может добавить друга через `/add_user` и увидеть его в списке `/users`.
- [ ] Добавленный друг, написав `/start` и `/get_config`, получает персональный WireGuard-конфиг, который реально работает на Windows и iOS.
- [ ] Если друг уже получал конфиг, повторный вызов `/get_config` выдаёт тот же (или актуальный) конфиг без создания дублей peers.
- [ ] Команда `/regen` создаёт новый peer и конфиг, а старый больше не используется (либо деактивирован, либо удалён).
- [ ] В `peers.json` для каждого пользователя хранится информация об одном активном peer (на текущем этапе).
- [ ] Внесённые изменения не ломают уже рабочий доступ владельца (client1).

## Из каких шагов состоит реализация

### Шаг 1: Завершить модель данных peers
**Что сделать:** 
- Финализировать датакласс `Peer` и функции работы с `peers.json` (`get_all_peers`, `find_peer_by_telegram_id`, `upsert_peer`).
- Определить формат хранения: `telegram_id`, `wg_ip`, `public_key`, `server_id`, `active`.

**Что проверить:** 
- Создание/чтение/обновление `peers.json` работает без ошибок, даже если файл отсутствует или повреждён (мягкий fallback).

**Тесты:** 
- Юнит-тесты на round-trip: `Peer` → dict → JSON → dict → `Peer`.

**Логирование:** 
- Логировать ошибки чтения/записи файлов как warning/error.

### Шаг 2: Увязать бота с моделью пользователей и peers
**Что сделать:** 
- В `bot/main.py`:
  - при `/get_config` использовать `find_user` и `find_peer_by_telegram_id`;
  - если пользователь отсутствует или неактивен — выводить понятное сообщение;
  - если peer есть — переходить к выдаче конфига;
  - если peer нет — вызывать логику создания нового peer.

**Что проверить:** 
- Никаких изменений в поведении для неавторизованных пользователей (бот по-прежнему вежливо отказывает).
- Админ по `/users` видит список, как и раньше.

**Тесты:** 
- Мокированные тесты на команды `/get_config` с разными состояниями (нет пользователя, есть пользователь без peer, есть пользователь с peer).

**Логирование:** 
- Логировать каждый вызов `/get_config` (кто, какой результат: нет доступа / выдан старый конфиг / создан новый).

### Шаг 3: Интеграция с WireGuard (создание/обновление peer)
**Что сделать:** 
- Реализовать модуль/функцию, которая:
  - генерирует ключи для нового peer (через `wg genkey | wg pubkey` или аналог);
  - выбирает свободный IP из заданного диапазона (на основе уже существующих peers);
  - добавляет новый блок `[Peer]` в `wg0.conf` и применяет конфигурацию (`wg syncconf wg0 <(wg-quick strip wg0)` или другой безопасный способ);
  - формирует текст клиентского `.conf` с учётом настроек DNS, Endpoint и т.п.

**Что проверить:** 
- После добавления peer’а WireGuard продолжает работать, старые подключения не отваливаются.
- Новый конфиг реально даёт доступ в интернет через VPN.

**Тесты:** 
- Тесты на чистой (тестовой) конфигурации `wg0.conf` в файловой системе (без реального применения), чтобы проверить корректность генерации блоков `[Peer]` и выбор IP.

**Логирование:** 
- Логировать успешное создание каждого peer (telegram_id, выделенный IP, server_id).
- Логировать ошибки при любых операциях с WireGuard.

### Шаг 4: Выдача конфига и QR через бота
**Что сделать:** 
- Добавить в бота:
  - отправку `.conf` файла как документа;
  - опционально — генерацию PNG с QR-кодом и его отправку пользователю по запросу.

**Что проверить:** 
- Конфиг можно импортировать в WireGuard на Windows и iOS без ручного редактирования.
- QR-код корректно распознаётся приложением WireGuard.

**Тесты:** 
- Ручные тесты на реальных клиентах (Windows/iOS).

**Логирование:** 
- Логировать факт выдачи нового/существующего конфига пользователю.

### Шаг 5: Регенерация (`/regen`) и отзыв доступа
**Что сделать:** 
- Определить политику регенерации:
  - переиспользовать IP, меняя только ключи;
  - или выдавать новый IP и освобождать старый.
- Реализовать логику деактивации старого peer и создания нового.

**Что проверить:** 
- Старый конфиг перестаёт работать после регенерации.
- Новый конфиг работает стабильно.

**Тесты:** 
- Сценарии: пользователь запросил `/regen`, старый туннель поднят/опущен, новый конфиг активирован.

**Логирование:** 
- Логировать все операции регенерации и отзыва доступа.

## Тесты

### Тест 1: Новый пользователь получает рабочий конфиг
**Что тестируем:** 
- Пользователь добавлен владельцем → пишет боту → получает рабочий VPN-конфиг.

**Ожидаемый результат:** 
- Подключение через WireGuard на Windows и iOS успешно, IP меняется на IP сервера, скорость/пинг на уровне уже протестированного MVP.

### Тест 2: Пользователь без доступа
**Что тестируем:** 
- Пользователь, которого нет в `users.json`, пишет `/get_config`.

**Ожидаемый результат:** 
- Бот вежливо сообщает, что доступ не выдан, и просит обратиться к владельцу; никаких конфигов или ключей не создаётся.

### Тест 3: Повторный запрос `/get_config`
**Что тестируем:** 
- Пользователь с уже созданным peer несколько раз вызывает `/get_config`.

**Ожидаемый результат:** 
- Бот выдаёт актуальный конфиг, не создавая новых peers и не плодя дубликаты IP.

### Тест 4: `/regen`
**Что тестируем:** 
- Пользователь вызывает `/regen`, затем `/get_config`.

**Ожидаемый результат:** 
- Старый конфиг перестаёт работать, новый даёт доступ; в `peers.json` и на сервере видно только один активный peer для этого Telegram ID.

## Как мы поймем, что все работает как надо

- [ ] Все критерии приемки из раздела «Как должен выглядеть результат» выполнены.
- [ ] Все автоматические и ручные тесты проходят.
- [ ] Код соответствует `docs/patterns.md`, проверен линтером.
- [ ] Добавлено логирование ключевых операций (создание peer, выдача конфига, регенерация).
- [ ] Нет hardcoded секретов (токены, ключи, IP не жёстко зашиты в код).
- [ ] Документация обновлена (`ROADMAP_VPN`, `DONE_LIST_VPN`, `SESSION_SUMMARY_YYYY-MM-DD.md`, `VPN/docs/deployment.md`).
- [ ] После деплоя на сервер VPN остаётся стабильным, существующие пользователи не теряют доступ без явного решения владельца.

## Как ничего не сломать в процессе

- [ ] Перед изменениями сохранить резервную копию текущего `wg0.conf` и данных WireGuard.
- [ ] Протестировать новую логику на отдельном тестовом пользователе, прежде чем добавлять массово друзей.
- [ ] При ошибках в интеграции иметь возможность быстро откатиться к текущей (ручной) схеме выдачи конфигов.
- [ ] Избегать прямого редактирования рабочих конфигов без бэкапа.

## Потенциальные проблемы и риски

- **Риск 1:** Ошибка в генерации или применении конфигурации WireGuard может временно отключить всех пользователей.
  - **Митигация:** Всегда иметь бэкап `wg0.conf` и инструкции из `VPN/docs/deployment.md` для быстрого восстановления.
- **Риск 2:** Неправильное распределение IP-адресов (конфликты, дубликаты).
  - **Митигация:** Использовать централизованное хранилище `peers.json` как источник правды и тщательно тестировать алгоритм выбора IP.
- **Риск 3:** Утечка конфигов или ключей через логи или неаккуратное хранение.
  - **Митигация:** Не логировать приватные ключи и содержимое `.conf`, хранить секреты только в `env_vars.txt` / `.env`.

## Альтернативные решения

- Вариант А: Делать всё через отдельный backend-сервис (HTTP API), с которым бот общается по сети.
  - Минусы: сложнее деплой, дополнительная точка отказа, избыточно для MVP.
- Вариант Б: Только полуавтоматический режим (бот уведомляет админа, админ вручную создаёт peer и конфиг).
  - Минусы: много ручной работы, плохо масштабируется при росте количества пользователей.
- **Выбран:** Прямое управление WireGuard с того же сервера, где крутится бот, через локальные скрипты и CLI (минимальный набор компонентов, проще деплой и отладка на этапе self-service для друзей).

## Оценка времени (очень грубо)

- Шаг 1–2 (модель данных и связка с ботом): ~2–4 часа.
- Шаг 3 (интеграция с WireGuard, без учёта сложных сценариев): ~4–8 часов.
- Шаг 4 (выдача конфига/QR и UX): ~2–4 часа.
- Шаг 5 (регенерация и отзыв): ~3–5 часов.
- Тестирование и доводка: ~3–6 часов.
- **Итого:** ~14–27 часов чистой работы (зависит от числа итераций и правок).

